# 로렘입숨 (2025-05-)
## 1. GDScript 배우기
1. [Hello world](#hello-world-출력하기)<br>
2. [변수](#변수-알아보기)<br>
3. [열거형 enum](#열거형-enum) <br>
4. [배열](#배열-배우기) <br>
5. [함수(메서드)](#함수메서드)<br>
6. [pass](#pass)<br>
7. [if, match 조건문](#if-조건문과-match-조건문)<br>
8. [반복문](#반복문)
9. [클래스](#클래스)
---
### Hello world 출력하기
```gd
extends Node


# Called when the node enters the scene tree for the first time.
func _ready() -> void: # 유니티의 Start
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void: # 유니티의 Update
	pass
```
- 가장 기본적인 스크립트로
- `func`는 함수를 나타내며,
- _ready() 는 유니티의 Start / _process(delta:float) 는 유니티의 Update 메서드라 생각하자.

```
extends Node


# Called when the node enters the scene tree for the first time.
func _ready() -> void: # 유니티의 Start
	print("Hello world!")


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void: # 유니티의 Update
	pass
```
- `_ready()` 메서드 속, `print("Hello world!")` 를 입력하고 스크립트를 메인 씬의 노드로서 저장하면, 출력 화면에 `Hello world` 가 재생된다.
> Hello world!
---
### 변수 알아보기
``` 
var number1 = 1 # 숫자 변수 선언
var number2 = 2

var result = number1 + number2

var my_name = "홍길동" # 문자열 저장 가능

var boxname = 123 

var am_i_hansome = true # 참 거짓의 bool 저장 가능

const yes_value = 1 # 상수 선언
```
- 여러 `변수`들을 여기서는 `var` 로 퉁쳐서 선언할 수 있다.
- `상수` 선언할 때는 `const` 로 선언할 수 있다.
---
### 열거형 enum
```
enum {ALLIANCE, ENEMY, UNKNOWN, }
enum Named {IDLE = 12, RUN, JUMP = 14 }
```
- 열거형 `enum` 은 `상수들을 묶어서 편하게 사용`할 수 있도록 만든 것이다.
- 일반적인 상수와는 달리, `숫자만` 담을 수 있다.
- 게임에서 발생한 상황이나 상태를 알아보기 쉽도록 숫자 대신 문자로 표현할 때 유용하다.
- 관행적으로, `열거형의 이름들은 알아보기 쉽게 대문자로 작성`한다.
```
enum {ALLIANCE, ENEMY, UNKNOWN, }
```
- 숫자들을 따로 작성하지 않는다면, `왼쪽부터 차례대로 0, 1, 2 ... 의 숫자`가 들어간다.
```
enum {ALLIANCE, ENEMY, UNKNOWN, }
enum Named {IDLE = 12, RUN, JUMP = 14 }

func _ready() -> void:
	print("Hello world!")
	print(ALLIANCE)
	print(ENEMY)
	print(UNKNOWN)
```
- 위 코드를 실행시켜보면, 

> Hello world!     <br>
> 0             <br>
> 1             <br>
> 2            <br>

- 위와 같은 출력 결과가 나타난다.
---
```
enum Named {IDLE = 12, RUN, JUMP = 14 }

func _ready() -> void:
    print(Named.RUN)
```
- 위와 같은 코드를 실행 시키면, `13` 이라는 값이 출력된다.
- enum 에서 처음에 숫자가 정해진다면(IDLE 에 12 값 들어감), 그 다음에 오는 상수는 다음 숫자가 대입된다.
- 따라서, RUN 이라는 상수는 13 값이 대입된다.
- 추가적으로, enum 자체에 이름을 붙여줄 수 있다.
```
enum Named {IDLE = 12, RUN, JUMP = 14}
```
- 이렇게 작성하면, `Named` 라는 이름의 `열거형 enum` 이 완성된다. 이를 `Named Enum` 이라고 한다.
- `이름있는 enum(Named Enum)` 을 사용할 때는, `.` 을 사용하여 출력해야 한다.
```
print(Named.RUN)
```
---
### 배열 배우기
- 배열은 여러 데이터를 한꺼번에 담는 상자로 이해하면 된다.
``` GDScript
var NAME =["a", "b", "c"] # NAME 이라는 이름의 3개의 요소를 가지는 배열 생성

func _ready() -> void:
	print(NAME)
	print(NAME[0])
	print(NAME[1])
	print(NAME[2])
```
> 출력결과<br>
> [a, b, c] <Br>
> a <Br>
> b <br>
> c <br>
---
### 함수(메서드)
- `함수` 는 다양한 `기능`들을 묶어서 편하게 사용하도록 만든 개념이다.
```
func TALK_function(my_input):
	print (my_input)
	print("라고 하겠습니다")
	
func 단호박_function() -> String:
	return "안됩니다"

func _ready() -> void:
	TALK_function("안녕하세요")
	TALK_function("반갑습니다")
	TALK_function(단호박_function())
```
### 출력결과
> 안녕하세요 <br>
> 라고 하겠습니다<br>
> 반갑습니다<br>
> 라고 하겠습니다<br>
> 안됩니다<br>
> 라고 하겠습니다<br>
- `함수(메서드)`를 선언할 때는 `func` 를 사용한다.
- 함수를 선언할 때, `func 함수의_이름(입력데이터를_받을_변수):` 형식으로 만든다.
- 입력받을 데이터가 없다면 `()` 만 적는다.
```
func 단호박_function() -> String:
    return "안됩니다"
```
- 위와 같이, 함수가 `어떤 값(안됩니다)` 을 `반환`하게 만들고 싶다면, `return` 문을 사용하여 반환할 값을 입력한다.
- 이때, 앞수 뒤쪽으로 `->` 와 반환할 값의 `반환형식(String)` 을 작성한다.
- 이제, `단호박_function()` 함수가 실행되면, `"안됩니다"` 라는 `문자열이 반환`된다.
- 주의할 점은, 함수의 `반환 값`은 `하나만 존재`한다. 함수를 실행하고 반환하는 값은 여러 개가 될 수 없으며, 오직 한 가지 값만 반환한다.
---
### pass
``` GDScript
func 함수(): # 오류 발생!
	

func 프리패스():
	pass
```
- GDScript 에서는, `함수나 조건문에 내용이 없는 경우`, 즉 `:` 뒤쪽으로 아무런 내용이 없는 경우 `오류를 발생`시킨다.
- `func 함수():` 뒤에 내용이 없기 때문에 `오류가 발생`한다.
- 하지만, func 프리패스(): 함수 뒤를 보면 `pass` 라는 키워드가 보인다.
- `pass` 키워드를 사용하면, `함수나 조건문 뒤에 내용이 없어도`, `오류를 발생시키지 않고 통과`하게 만들어준다.

---
### if 조건문과 match 조건문
``` GDScript
const 엄마나이 = 20
const 아빠나이 = 25

func _ready() -> void:
	# <if 조건문>
	if false:
		pass
	elif 엄마나이 < 아빠나이:
		print("아빠연상")
	elif 엄마나이 > 아빠나이:
		print("엄마연상")
	else:
		print("동갑")
	
	# <match 조건문>
	match 엄마나이:
		10: # 엄마나이 변수에 10이 저장되어있다면
			print("열살")
		20: # 엄마나이 변수에 20이 저장되어 있다면
			print("20살")
		_: # 위 조건들을 전부 만족하지 못했다면
			print("열살도 스무살도 아니다")
```
- 다른 언어에서도 사용하던 `if`~ `elif`~ `else` 문과 사용법이 동일하다.
- `match` 조건문은, C, C++, C# 등과 같은 언어에서 `switch` 문과 동일하다.
- 똑같은 값을 가지면 그 값에 맞는 기능을 수행한다.

---
### 반복문
- `조건을 만족`하면, `코드를 반복해서 수행`할 때 사용한다.
```
func _ready() -> void:
	for 십일부터십이까지만 in range(11, 13): # 마지막 숫자 포함 X
		print(십일부터십이까지만)
	
	for 배열에서숫자하나씩꺼내기 in [3, 6, 9]:
		print(배열에서숫자하나씩꺼내기)
	
	for 문자하나씩꺼내기 in "Hello":
		if 문자하나씩꺼내기 == "H":
			continue # H 문자를 마주하면 아래 내용은 무시하고 반복 진행
		print(문자하나씩꺼내기)
	
	var 남은기름 = 10
	var 이동거리 = 0
	
	while 남은기름 > 0:
		이동거리 = 이동거리 + 1
		남은기름 = 남은기름 - 1
		print("남은기름 = ", 남은기름)
		
		if (남은기름 <= 3):
			break # 남은 기름이 3 이하라면 while 반복문 종료
	print("이동거리 = ", 이동거리)
```
- 기존에 사용하던 `for 문`과 조금 구성이 다르다.
```
for 십일부터십이까지만 in range(11, 13): # 마지막 숫자 포함 X
	print(십일부터십이까지만)
```
- `11~13` 까지의 숫자들을 하나씩 `출력`해준다.
- 이때, `마지막 숫자`인 `13` 은 출력되지 않는다.
> 출력결과 <br>
> 11 <br>
> 12<br>

```
for 배열에서숫자하나씩꺼내기 in [3, 6, 9]:
	print(배열에서숫자하나씩꺼내기)
```
- `숫자들 배열`에서도 하나씩 출력할 수 있다.
> 출력결과 <br>
> 3<br>
> 6<br>
> 9<br>

```
for 문자하나씩꺼내기 in "Hello":
	if 문자하나씩꺼내기 == "H":
		continue # H 문자를 마주하면 아래 내용은 무시하고 반복 진행
	print(문자하나씩꺼내기)
```
- 마찬가지로, `문자열에서 문자 하나씩 꺼내서 출력`할 수 있다.
- 이때, `if 조건문`과 그 뒤에 있는 `continue` 에 의해서, `H` 문자열을 만났을 때는, `print` 를 무시하고 `반복문을 진행`하게 된다.
> 출력결과<br>
> e <br>
> l<br>
> l<br>
> o<br>

```
var 남은기름 = 10
var 이동거리 = 0
	
while 남은기름 > 0:
	이동거리 = 이동거리 + 1
	남은기름 = 남은기름 - 1
	print("남은기름 = ", 남은기름)
	
	if (남은기름 <= 3):
		break # 남은 기름이 3 이하라면 while 반복문 종료

print("이동거리 = ", 이동거리)
```
- `조건이 참`인동안, `계속 반복`하는 `while` 반복문도 존재한다.
- `break` 가 실행되면, while 반복문을 종료하고 `다음 코드를 실행`한다.
> 출력결과
> 남은기름 = 9<br>
> 남은기름 = 8<br>
> 남은기름 = 7<br>
> 남은기름 = 6<br>
> 남은기름 = 5<br>
> 남은기름 = 4<br>
> 남은기름 = 3<br>
> 이동거리 = 7<br>
---
### 클래스
``` GDScript
# 메인 씬 중 스크립트 파일 내부
class_name 자동차클래스 # 클래스 이름 선언
extends Node # 상속의 개념

# 속성들(변수)
var 최고속력 = 30
var 색상 = "파랑"

# 행동들(함수)
func 시동켜기():
	print("배기음")
	
func 시동끄기():
	print("시동꺼지는소리")
```
- `클래스`를 `선언`할 때는, 스크립트 `맨 위`에 `class_name` 을 사용하여 클래스를 제작한다.
- `class_name` 을 적고 원하는 `클래스 이름을 작성`하면 된다.
- 이후, 이 클래스에 들어갈 `변수`와 `함수`들을 `작성`한다.
![](./만든클래스%20확인.png)
- 만든 클래스를 확인하기 위해, `씬`에 `자식 노드를 추가`하고, `자식 코드에 스크립트를 추가`하였다.
```
# 자식 노드 속 truck 스크립트
extends 자동차클래스 # 앞서 만든 클래스를 "상속" 받는다.

func _ready() -> void:
	# 자동차클래스에서 만든 변수들 사용이 가능함.
	print("최고속력 : ", 최고속력)
	print("차량 색깔 : ", 색상)
	
	# 자동차클래스에서 만든 함수들 사용이 가능함.
	시동켜기()
	시동끄기()
```
- `클래스`를 `상속`받을 때는 `extends 클래스_이름` 의 형식으로 상속받는다.
- 클래스를 `상속`받으면, 그 `클래스 `속 `미리 선언된 변수들과 함수들을 사용`할 수 있다.
> 출력결과 <br>
> 최고속력 : 30 <br>
> 차량 색깔 : 파랑 <br>
> 배기음 <br>
> 시동꺼지는소리 <br>
- `상속` 에서 주의할 점은, 클래스를 상속받은 `자식 클래스`에서 `변수를 변경`하면, 이는 `자식 클래스 내부에서 사용되는 변수의 값이 변경`된 것이지, `부모 클래스에 원래 변수의 값을 변경시키지 못한다`. 
### 즉, 자식 클래스에서의 변화가 부모 클래스 까지 가지 않는다.

```
extends 자동차클래스 # 앞서 만든 클래스를 "상속" 받는다.

func 시동켜기(): # 함수 오버라이딩, 부모 클래스에서 받은 함수를 자식 클래스에서 재정의할 수 있다.
	print("털털털털")

func _ready() -> void:
	# 자동차클래스에서 만든 변수들 사용이 가능함.
	print("최고속력 : ", 최고속력)
	print("차량 색깔 : ", 색상)
	
	# 자동차클래스에서 만든 함수들 사용이 가능함.
	시동켜기()
	시동끄기()
```
- 두번째 단의 `시동켜기() 함수`를 `오버라이딩` 하는 모습이 보이는가?
- 부모 클래스를 `상속`받아 만들어진 `자식 클래스`에선, `부모 클래스의 함수를 재정의`하여 사용할 수 있다.
- 따라서, 위 코드를 실행시키면
> 출력결과 <br>
> 최고속력 : 30 <br>
> 차량 색깔 : 파랑 <br>
> ### 털털털털 <br>
> 시동꺼지는소리 <br>
- 강조된 부분인 `func 시동켜기()` 함수가 `재정의`된 것을 볼 수 있다.
- `함수 오버라이딩` 도 가능하다!
```
extends 자동차클래스 # 앞서 만든 클래스를 "상속" 받는다.

var 인스턴스 = 자동차클래스.new()

func 시동켜기(): # 함수 오버라이딩, 부모 클래스에서 받은 함수를 자식 클래스에서 재정의할 수 있다.
	print("털털털털")

func _ready() -> void:
	# 자동차클래스에서 만든 변수들 사용이 가능함.
	print("최고속력 : ", 최고속력)
	print("차량 색깔 : ", 색상)
	
	# 자동차클래스에서 만든 함수들 사용이 가능함.
	시동켜기()
	시동끄기()
	
	# 자동차 클래스로 개체를 만들 수 있다.
	인스턴스.시동켜기()
	인스턴스.시동끄기()
	print("색깔 : ", 인스턴스.색상)
```
- 두번째 단에 `var 인스턴스 = 자동차클래스.new()` 가 보이는가?
- 이는, `"자동차클래스"` 클래스의 `개체`를 `직접 만드는 것`이다.
- 즉, `클래스를 가지는 개체 인스턴스`를 만들어 이를 사용할 수 있도록 하는 것이다.
```
	# 자동차 클래스로 개체를 만들 수 있다.
	인스턴스.시동켜기()
	인스턴스.시동끄기()
	print("색깔 : ", 인스턴스.색상)
```
- 이렇게 만들어진 인스턴스를 생성할 때는, `인스턴스_이름.클래스_속_변수나_함수` 형식으로 사용한다.
- 이렇게 만들어진 `인스턴스`는, `부모 클래스 자체로 만들어진 개체`이다.
- 따라서, 전체 코드에서 `자식 클래스`에서 `함수 오버라이딩`한 `func 시동켜기():` 함수가 `인스턴스 한테는 적용되지 않는다`.

> 전체코드 출력결과<br>
> 최고속력 : 30<br>
> 차량 색깔 : 파랑<br>
> 털털털털<br>
> 시동꺼지는소리<br>
> ### 배기음
> ### 시동꺼지는소리
> ### 색깔 : 파랑
- `인스턴스 개체가 사용된 부분`을 보면, `함수 오버라이딩이 적용되지 않은 것`을 알 수 있다.
